#!/usr/bin/env python
"""Create random morphology files for unit testing."""
from __future__ import annotations

import collections
import itertools
import pathlib
import random
import sys
from collections.abc import Sequence
from typing import Tuple

from morphio import mut

# x, y, z, parent
TreeNode = Tuple[float, float, float, int]
# type, x, y, z, radius, parent
SWCLine = Tuple[int, float, float, float, float, int]


def grow(value: float, scale: float) -> float:
    """Increase or increase value by a displacement between 0 and scale.

    Parameters
    ----------
    value
        The value to make a random step from.
    scale
        The scale of the random step.

    Returns
    -------
    float
        The new value. It will be in the range
        ``[scale - value, scale + value]``.
    """
    delta = 2 * random.random() - 1
    return value + delta * scale


def write(neuron: Sequence[SWCLine], path: pathlib.Path) -> None:
    """Write neuron SWC lines to disk.

    Parameters
    ----------
    neuron
        A sequence of SWC lines that represent an entire neuron
    path
        The neuron output path. It's recommended that the file name
        has the extension ".swc".
    """
    path.parent.mkdir(exist_ok=True, parents=True)
    with path.open("w") as fh:
        for idx, (kind, x, y, z, radius, parent) in enumerate(neuron):
            idx += 1
            if parent != -1:
                parent += 1
            fh.write(
                f"{idx}\t{kind}\t{x:.9f}\t{y:.9f}\t{z:.9f}\t{radius:.9f}\t{parent}\n"
            )

    # Re-process the SWC file with MorphIO to standardize the line order.
    # Without this the TMD package had difficulties processing the neurons.
    morphology = mut.Morphology(path)
    morphology.write(path)

    # Replace the MorphIO header, which contains the MorphIO version, by
    # our own header
    with path.open() as fh:
        lines = list(fh)
    with path.open("w") as fh:
        fh.write(f"# Generated by {pathlib.Path(__file__).name}\n")
        for line in itertools.islice(lines, 1, None):
            fh.write(line)


def make_tree(*, n_points: int, scale: float) -> list[TreeNode]:
    """Generate a random 3D tree.

    Parameters
    ----------
    n_points
        The number of points in the tree.
    scale
        The tree scale. This is the maximal value by which the coordinates
        of two connected nodes can differ.

    Returns
    -------
    list[TreeNode]
        A sequence of tree nodes. Each node is a tuple with four elements:
        The three spacial coordinates x, y, z, and the index of the parent
        node.
    """
    # x, y, z, parent
    points = [(0.0, 0.0, 0.0, -1)]
    # indices of the current tree tips/leaves to which we can append
    tips = {0}
    # track the number of children of each node to avoid multi-furcations
    n_children: dict[int, int] = collections.defaultdict(int)
    # the branching probability
    p_branch = 0.1
    for _ in range(n_points):
        parent = random.sample(tips, 1).pop()
        tips.remove(parent)
        n_children[parent] += 1
        x, y, z, _ = points[parent]
        points.append((grow(x, scale), grow(y, scale), grow(z, scale), parent))
        # the point just added becomes a leaf
        tips.add(len(points) - 1)
        # potentially make the parent point a branching point
        if parent != 0 and n_children[parent] < 2 and random.random() < p_branch:
            tips.add(parent)

    return points


def attach_neurite(
    neuron: Sequence[SWCLine],
    tree: Sequence[TreeNode],
    *,
    kind: int,
    min_radius: float = 0.1,
    max_radius: float = 0.3,
) -> list[SWCLine]:
    """Attach a new neurite to a neuron.

    The branch radius value will be randomly sampled.

    Parameters
    ----------
    neuron
        A neuron represented as a sequence of SWC lines. The first
        line is assumed to be the soma point and the new neurite is
        attached to it.
    tree
        A neurite tree. The first node is assumed to be the root and will
        be replaced by the soma point of the neuron.
    kind
        The neurite type. According to the SWC standard the types are as
        follows:

        * ``1``: soma
        * ``2``: axon
        * ``3``: basal dendrite
        * ``4``: apical dendrite

    min_radius
        The lower bound for the random radius sampling.
    max_radius
        The upper bound for the random radius sampling.

    Returns
    -------
    list[SWCLine]
        The updated neuron.
    """
    # The parent value refers to the position in the list. As we append
    # the points to the neuron their index shifts.
    shift = len(neuron) - 1
    new_neuron = list(neuron)  # shallow copy, convert to mutable type
    for x, y, z, parent in itertools.islice(tree, 1, None):  # drop tree root
        if parent != 0:  # the soma stays at index 0
            parent += shift
        radius = random.random() * (max_radius - min_radius) + min_radius
        new_neuron.append((kind, x, y, z, radius, parent))

    return new_neuron


def random_neuron() -> list[SWCLine]:
    """Generate a random neuron.

    Returns
    -------
    list[SWCLine]
        A random neuron.
    """
    # type, x, y, z, radius, parent
    neuron: list[SWCLine] = [(1, 0.0, 0.0, 0.0, 0.2, -1)]  # the soma point
    neuron = attach_neurite(neuron, make_tree(n_points=300, scale=15), kind=2)
    neuron = attach_neurite(neuron, make_tree(n_points=50, scale=5), kind=3)
    neuron = attach_neurite(neuron, make_tree(n_points=50, scale=5), kind=3)
    neuron = attach_neurite(neuron, make_tree(n_points=50, scale=5), kind=3)
    neuron = attach_neurite(neuron, make_tree(n_points=100, scale=10), kind=4)

    return neuron


def main() -> int:
    random.seed(20042022)
    cwd = pathlib.Path(__file__).parent
    write(random_neuron(), cwd / "L5" / "TPC_A" / "random1.swc")
    write(random_neuron(), cwd / "L5" / "TPC_A" / "random2.swc")
    write(random_neuron(), cwd / "L5" / "TPC_B" / "random3.swc")
    write(random_neuron(), cwd / "L5" / "TPC_B" / "random4.swc")
    write(random_neuron(), cwd / "L5" / "TPC_C" / "random5.swc")
    write(random_neuron(), cwd / "L5" / "TPC_C" / "random6.swc")
    write(random_neuron(), cwd / "L5" / "UPC" / "random7.swc")
    write(random_neuron(), cwd / "L5" / "UPC" / "random8.swc")
    write(random_neuron(), cwd / "L6" / "BPC" / "random9.swc")

    return 0


if __name__ == "__main__":
    sys.exit(main())
